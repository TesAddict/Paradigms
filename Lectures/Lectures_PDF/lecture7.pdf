%!PS-Adobe-3.0
%%Title: lecture7.scm
%%For: methos
%%Creator: VIM - Vi IMproved 8.0 (2016 Sep 12)
%%CreationDate: Tue Mar  5 22:14:09 2019
%%DocumentData: Clean8Bit
%%Orientation: Portrait
%%Pages: (atend)
%%PageOrder: Ascend
%%BoundingBox: 61 42 577 752
%%DocumentMedia: letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%DocumentSuppliedResources: procset VIM-Prolog 1.4 1
%%+ encoding VIM-latin1 1.0 0
%%Requirements: duplex collate color
%%EndComments
%%BeginDefaults
%%PageResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%PageMedia: letter
%%EndDefaults
%%BeginProlog
%%BeginResource: procset VIM-Prolog
%%BeginDocument: /usr/share/vim/vim80/print/prolog.ps
%!PS-Adobe-3.0 Resource-ProcSet
%%Title: VIM-Prolog
%%Version: 1.4 1
%%EndComments
% Editing of this file is NOT RECOMMENDED.  You run a very good risk of causing
% all PostScript printing from VIM failing if you do.  PostScript is not called
% a write-only language for nothing!
/packedarray where not{userdict begin/setpacking/pop load def/currentpacking
false def end}{pop}ifelse/CP currentpacking def true setpacking
/bd{bind def}bind def/ld{load def}bd/ed{exch def}bd/d/def ld
/db{dict begin}bd/cde{currentdict end}bd
/T true d/F false d
/SO null d/sv{/SO save d}bd/re{SO restore}bd
/L2 systemdict/languagelevel 2 copy known{get exec}{pop pop 1}ifelse 2 ge d
/m/moveto ld/s/show ld /ms{m s}bd /g/setgray ld/r/setrgbcolor ld/sp{showpage}bd
/gs/gsave ld/gr/grestore ld/cp/currentpoint ld
/ul{gs UW setlinewidth cp UO add 2 copy newpath m 3 1 roll add exch lineto
stroke gr}bd
/bg{gs r cp BO add 4 -2 roll rectfill gr}bd
/sl{90 rotate 0 exch translate}bd
L2{
/sspd{mark exch{setpagedevice}stopped cleartomark}bd
/nc{1 db/NumCopies ed cde sspd}bd
/sps{3 db/Orientation ed[3 1 roll]/PageSize ed/ImagingBBox null d cde sspd}bd
/dt{2 db/Tumble ed/Duplex ed cde sspd}bd
/c{1 db/Collate ed cde sspd}bd
}{
/nc{/#copies ed}bd
/sps{statusdict/setpage get exec}bd
/dt{statusdict/settumble 2 copy known{get exec}{pop pop pop}ifelse
statusdict/setduplexmode 2 copy known{get exec}{pop pop pop}ifelse}bd
/c{pop}bd
}ifelse
/ffs{findfont exch scalefont d}bd/sf{setfont}bd
/ref{1 db findfont dup maxlength dict/NFD ed{exch dup/FID ne{exch NFD 3 1 roll
put}{pop pop}ifelse}forall/Encoding findresource dup length 256 eq{NFD/Encoding
3 -1 roll put}{pop}ifelse NFD dup/FontType get 3 ne{/CharStrings}{/CharProcs}
ifelse 2 copy known{2 copy get dup maxlength dict copy[/questiondown/space]{2
copy known{2 copy get 2 index/.notdef 3 -1 roll put pop exit}if pop}forall put
}{pop pop}ifelse dup NFD/FontName 3 -1 roll put NFD definefont pop end}bd
CP setpacking
(\004)cvn{}bd
% vim:ff=unix:
%%EOF
%%EndDocument
%%EndResource
%%BeginResource: encoding VIM-latin1
%%BeginDocument: /usr/share/vim/vim80/print/latin1.ps
%!PS-Adobe-3.0 Resource-Encoding
%%Title: VIM-latin1
%%Version: 1.0 0
%%EndComments
/VIM-latin1[
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle
/parenleft /parenright /asterisk /plus /comma /minus /period /slash
/zero /one /two /three /four /five /six /seven
/eight /nine /colon /semicolon /less /equal /greater /question
/at /A /B /C /D /E /F /G
/H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore
/grave /a /b /c /d /e /f /g
/h /i /j /k /l /m /n /o
/p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /periodcentered
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
/Encoding defineresource pop
% vim:ff=unix:
%%EOF
%%EndDocument
%%EndResource
%%EndProlog
%%BeginSetup
612 792 0 sps
1 nc
T F dt
T c
%%IncludeResource: font Courier
/_F0 /VIM-latin1 /Courier ref
/F0 10 /_F0 ffs
%%IncludeResource: font Courier-Bold
/_F1 /VIM-latin1 /Courier-Bold ref
/F1 10 /_F1 ffs
%%IncludeResource: font Courier-Oblique
/_F2 /VIM-latin1 /Courier-Oblique ref
/F2 10 /_F2 ffs
%%IncludeResource: font Courier-BoldOblique
/_F3 /VIM-latin1 /Courier-BoldOblique ref
/F3 10 /_F3 ffs
/UO -1 d
/UW 0.5 d
/BO -2.5 d
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 1)61.2 744.9 ms
F0 sf
0.753 0 0 r
(; CSc 335)61.2 714.9 ms
(; Lecture 7 )61.2 704.9 ms
(; March 5 2019)61.2 694.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 674.9 ms
(; ninth class meeting)61.2 654.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 634.9 ms
(; The focus is on introducing the material in TLS)61.2 614.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 594.9 ms
(; Material from TLS, with ideas on inductive definitions, Backus-Naur form and)61.2 574.9 ms
(; box and pointer diagrams added in class)61.2 564.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 544.9 ms
(; an atom is a string of letters, digits, or characters other than \( or \) - no spaces,)61.2 524.9 ms
(; either)61.2 514.9 ms
(;; atom)61.2 494.9 ms
(;; turkey)61.2 484.9 ms
(;; 1492)61.2 474.9 ms
(;; abc$2)61.2 464.9 ms
(; lists are collections of atoms or lists enclosed by parentheses)61.2 434.9 ms
(;; \(atom turkey or\))61.2 414.9 ms
(;; \(\(atom turkey\) or\))61.2 404.9 ms
(;; \(\))61.2 394.9 ms
(; atoms and lists both belong to the class of S-expressions --)61.2 364.9 ms
(; here are some more examples)61.2 354.9 ms
(;; \(\))61.2 334.9 ms
(;; xyz)61.2 324.9 ms
(;; \(x y z\))61.2 314.9 ms
(;; \(\(x y\) z\))61.2 304.9 ms
(;; \(\(\)\))61.2 294.9 ms
(;; \(\(\(\) \(\)\) \(\) \))61.2 284.9 ms
(; an s-exp \("s-expression"\) is either an atom, the empty list, )61.2 244.9 ms
(; or a list of s-exps)61.2 234.9 ms
(; thus)61.2 214.9 ms
(; \(\)    is an s-exp)61.2 194.9 ms
(; xyz is an s-exp)61.2 174.9 ms
(; \(x y z\) is a list of s-exps, and hence an s-exp)61.2 154.9 ms
(; \(\(x y\) z\) is a list of two s-exps, \(x y\) and z, and hence is )61.2 134.9 ms
(; itself an s-exp)61.2 124.9 ms
(; that is, )61.2 94.9 ms
(;    s-exp ::=  atom | \(\) | \(s-exp ... s-exp\))61.2 74.9 ms
(;; clearly, every atom is an s-exp, and it seems reasonable)61.2 54.9 ms
(;; to say that every list is an s-exp, but as atoms are not)61.2 44.9 ms
re sp
%%PageTrailer
%%Page: 2 2
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 2)61.2 744.9 ms
F0 sf
0.753 0 0 r
(;; themselves lists, it is clear that not every s-exp is a list)61.2 724.9 ms
(; why is \(\(\(how\) are\) \(\(you\) \(doing so\)\) far\) an s-exp?  we use)61.2 694.9 ms
(; the definition to break the expression down into its constituents)61.2 684.9 ms
(; can you give a similar inductive definition of lists?  )61.2 644.9 ms
(; what about)61.2 624.9 ms
(;   list ::= \(\) | \(atom ... atom\) )61.2 604.9 ms
(; is this sufficiently broad? \(no!\) If not, can you repair it?  If you are not)61.2 584.9 ms
(; clear on this, don't worry: we will come back to it. )61.2 574.9 ms
(; functions for lists:  car, cdr and cons)61.2 534.9 ms
(; \(car \(a b c\)\) = a)61.2 504.9 ms
(; \(car \(\(a b c\) x y z\)\) = \(a b c\))61.2 484.9 ms
(; \(car \( \(\(hotdogs\)\) \(and\) \(pickle\) relish\)\) = \(\(hotdogs\)\))61.2 464.9 ms
(; \(car \(\(hotdogs\)\)\) = \(hotdogs\))61.2 444.9 ms
(; \(car \(car \(\(hotdogs\)\)\)\) = hotdogs)61.2 424.9 ms
(; \(car hotdogs\)  --> error)61.2 404.9 ms
(; \(car \(\)\) --> error)61.2 384.9 ms
(; \(cdr \(a b c\)\) = \(b c\))61.2 324.9 ms
(; \(cdr \(\(a b c\) x y z\) = \(x y z\))61.2 304.9 ms
(; \(cdr \(hamburger\)\) = \(\))61.2 284.9 ms
(; \(cdr hotdogs\) --> error)61.2 264.9 ms
(; \(cdr \(\)\) --> error)61.2 244.9 ms
(; \(car \(cdr \(\(b\) \(x y\) \(\(c\)\)\) = \(x y\))61.2 184.9 ms
(; \(cdr \(cdr \(\(b\) \(x y\) \(\(c\)\)\)\)\) = \(\(\(c\)\)\))61.2 154.9 ms
(; \(cdr \(car \(a \(b \(c\)\) d\)\) --> ?)61.2 124.9 ms
(; what does car take as an argument?)61.2 84.9 ms
(; what does cdr take as an argument?)61.2 64.9 ms
re sp
%%PageTrailer
%%Page: 3 3
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 3)61.2 744.9 ms
F0 sf
0.753 0 0 r
(; cons -- at some point, we need to ask how these lists are created in the first place)61.2 724.9 ms
(!)61.2 714.9 ms
(; \(cons peanut \(butter and jelly\)\) = \(peanut butter and jelly\))61.2 684.9 ms
(; \(cons \(banana and\) \(peanut butter and jelly\)\) = \(\(banana and\) peanut butter and jell)61.2 664.9 ms
(y\))61.2 654.9 ms
(; \(cons \(\(help\) this\) \(is very \(hard\) to learn\)\) = \(\(\(help\) this\) is very \(hard\) to le)61.2 634.9 ms
(arn\))61.2 624.9 ms
(; \(cons \(a b \(c\)\) \(\)\) = )61.2 604.9 ms
(; \(cons a \(\)\) = )61.2 584.9 ms
(; \(cons \(\(a b c\)\) b\) =)61.2 564.9 ms
(; what does cons take as its arguments?)61.2 534.9 ms
(; cons, car and cdr together)61.2 494.9 ms
(; \(cons a \(car \(\(b\) c d\) \)\))61.2 474.9 ms
(; \(cons a \(cdr\(\(b\) c d\)  \)\) )61.2 454.9 ms
(; in fact, we note that cons, car and cdr satisfy some equations:  )61.2 424.9 ms
(; \(car \(cons a b\)\) = a)61.2 404.9 ms
(; \(cdr \(cons a b\)\) = b)61.2 394.9 ms
(; can you think of another?)61.2 374.9 ms
(; how about \(cons \(car \(cons a b\)\) \(cdr \(cons a b\)\)\) = \(cons a b\))61.2 354.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 314.9 ms
(;;)61.2 304.9 ms
(; many of the car/cdr/cons computations given above can be explained via the simple vi)61.2 284.9 ms
(sual)61.2 274.9 ms
(; device of 'box and pointer' diagrams, as we indicate on the board)61.2 264.9 ms
(; in class.  you can find a discussion of such diagrams in SICP, in Section 2.2 --)61.2 254.9 ms
(; you will want to look at this, as we will be seeing these diagrams off and on throug)61.2 244.9 ms
(hout)61.2 234.9 ms
(; the rest of the term.)61.2 224.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 204.9 ms
(;;;)61.2 194.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 104.9 ms
(;;;)61.2 94.9 ms
(; now that we have introduced cons, what do you think of the following as a )61.2 64.9 ms
(; definition of lists?)61.2 54.9 ms
re sp
%%PageTrailer
%%Page: 4 4
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 4)61.2 744.9 ms
F0 sf
0.753 0 0 r
(;; ; list ::= \(\) | \(cons list list\))61.2 724.9 ms
(; We need to ask whether this recipe generates _only_ lists \(that is, whether)61.2 704.9 ms
(; it is a sound recipe for generating lists\), and whether it generates _all_ lists)61.2 694.9 ms
(; \(that is, whether it is complete for lists\).)61.2 684.9 ms
(; we argue by induction* that it is sound, and note that even this simple recipie)61.2 664.9 ms
(; is capable of generating some complex structures.  )61.2 654.9 ms
(; it is quite easy to see that it is not complete -- for example, the list)61.2 634.9 ms
(; \(a\) is not generated.)61.2 624.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 604.9 ms
(; *: induction on what?  In this case, induction on the number of times the rule)61.2 584.9 ms
(; is applied to generate a list.)61.2 574.9 ms
(; A formula such as this can be viewed as a)61.2 554.9 ms
(; generator: starting with \(\), it generates \(cons \(\) \(\)\) at the next level, and then)61.2 544.9 ms
(; \(cons \(\) \(cons \(\) \(\)\)\) and \(cons \(cons \(\) \(\)\) \(\)\) at the next.  Continuing in this)61.2 534.9 ms
(; way, one can enumerate all of the lists generated by this rule.)61.2 524.9 ms
(; But this is no way to verify that everything generated by the rule is in fact a list)61.2 504.9 ms
(.)61.2 494.9 ms
(; For that, we need an induction.  So: observe that every object generated by one appl)61.2 484.9 ms
(ication)61.2 474.9 ms
(; of the rule is a list -- \(\) and \(cons \(\) \(\)\) are both lists.  Next assume that an ob)61.2 464.9 ms
(ject)61.2 454.9 ms
(; list, after k applications of the rule, is a list -- that is, the cdr of its final c)61.2 444.9 ms
(ons)61.2 434.9 ms
(; is \(\).  Does this hold after one more step?  Clearly, yes: \(cons list list\) does not)61.2 424.9 ms
(; alter the last cons cell in list. )61.2 414.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 394.9 ms
(; What about taking care of atoms in the way suggested by this next \(candidate\) defini)61.2 364.9 ms
(tion?)61.2 354.9 ms
(;; list ::= \(\) | \(cons atom list\) | \(cons list list\)\))61.2 334.9 ms
(; is this sufficiently broad?  is it too broad?  Can we agree that it handles every )61.2 314.9 ms
(; example we have seen so far, and that everything it generates appears to )61.2 304.9 ms
(; be a list in the sense we mean, and then to take it as the definition of lists?  )61.2 294.9 ms
(; What good is it to have a definition formulated this way?  The answer jumps out )61.2 274.9 ms
(; when we consider the problem of designing and proving correct a program which)61.2 264.9 ms
(; processes lists.  Indeed, how could we do this if we did not have a precise)61.2 254.9 ms
(; characterization of the input?)61.2 244.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 214.9 ms
(; Here is a suggested homework problem for you:)61.2 194.9 ms
(; Critique, as a definition of the class of lists, )61.2 174.9 ms
(; list ::= \(\) | \(cons atom list\) | \(cons list \(list\)\))61.2 154.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 134.9 ms
(; let us agree for now that anything which is not a list is an atom,)61.2 104.9 ms
(; and that atom? is a predicate which checks whether its single argument)61.2 94.9 ms
(; is an atom.)61.2 84.9 ms
(; \(atom? 'atom\) )61.2 64.9 ms
(; \(atom? 'turkey\))61.2 54.9 ms
(; \(atom? 1492\))61.2 44.9 ms
re sp
%%PageTrailer
%%Page: 5 5
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 5)61.2 744.9 ms
F0 sf
0.753 0 0 r
(; \(atom? '\(a b c\)\))61.2 714.9 ms
(; \(atom? '\(\)\))61.2 704.9 ms
(; the predicate list? checks whether its single argument is a list)61.2 674.9 ms
(; \(list? 'atom\))61.2 654.9 ms
(; \(list? '\(atom\)\))61.2 644.9 ms
(; \(list? '\(\)\))61.2 624.9 ms
(; \(list? '\(a \(b c\)\)\))61.2 604.9 ms
(; atom?, list?, car, cdr and cons can of course be used together)61.2 574.9 ms
(; \(atom? \(car l\)\), where l is '\(Harry had a heap of apples\))61.2 554.9 ms
(; \(atom? \(cdr l\)\), for the same l)61.2 534.9 ms
(; \(list? \(cdr l\)\), for the same l)61.2 514.9 ms
(; \(atom? \(car \(cdr l\)\)\), where l is '\(swing low sweet cherry oat\))61.2 494.9 ms
(; and so on)61.2 474.9 ms
(; another useful predicate is pair?, which is more general than list?)61.2 434.9 ms
(; \(pair? \(cons 'a 'b\)\))61.2 414.9 ms
(; \(pair? \(cons 'a \(cons 'b '\(\)\)\)\))61.2 394.9 ms
(;   note that \(cons 'a \(cons 'b '\(\)\)\) = '\(a b\))61.2 374.9 ms
(; null? is the predicate used to check for the empty list:)61.2 334.9 ms
(; \(null? '\(\)\))61.2 314.9 ms
(; note that \(pair? '\(\)\) = #f )61.2 274.9 ms
(; while null?, pair? and list? are pre-defined in scheme, we must define atom? ourselv)61.2 234.9 ms
(es.  )61.2 224.9 ms
(; one way of doing this is as follows:)61.2 204.9 ms
0.753 0 0.753 r
(\()61.2 184.9 ms
0 0.502 0 r
(define)s
0 g
( atom?)s
(  )61.2 174.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(lambda)s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(x)s
0.753 0 0.753 r
(\))s
0 g
(    )61.2 164.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(and)s
0 g
( )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(not)s
0 g
( )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(pair?)s
0 g
( x)s
0.753 0 0.753 r
(\)\))s
0 g
( )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(not)s
0 g
( )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(null?)s
0 g
( x)s
0.753 0 0.753 r
(\)\)\)\)\))s
0.753 0 0 r
(; another built-in predicate is eq?, scheme's strongest equality predicate.  )61.2 124.9 ms
(; \(eq? a1 a2\), where a1 is 'Harry and a2 is 'Harry)61.2 104.9 ms
(; \(eq? 'margarine 'butter\))61.2 74.9 ms
(; \(eq? '\(\) '\(strawberry\)\))61.2 44.9 ms
re sp
%%PageTrailer
%%Page: 6 6
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 6)61.2 744.9 ms
F0 sf
(  )61.2 724.9 ms
0.753 0 0 r
(; \(eq? 6 7\) )61.2 714.9 ms
0 g
(  )61.2 704.9 ms
0.753 0 0 r
(; \(eq? \(car l\) a\), where l is \(Mary had a little lamb chop\) and a is Mary)61.2 694.9 ms
(; \(eq? \(cdr l\) a\), where l is \(soured milk\) and a is milk)61.2 674.9 ms
(; \(eq? \(car l\) \(car \(cdr l\)\)\) where l is \(beans beans we need jelly beans\))61.2 654.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 624.9 ms
(;;)61.2 614.9 ms
(; eq? checks for pointer identity)61.2 594.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 574.9 ms
(;;;)61.2 564.9 ms
(; what about carrying out some of the car/cdr/cons calculations on the computer?  )61.2 544.9 ms
(;; [some scheme examples shown in class] )61.2 524.9 ms
(; The thing to keep in mind is, roughly, that scheme)61.2 504.9 ms
(; tries to evaluate everything.  When we ask for \(car \(a b c\)\), it will)61.2 494.9 ms
(; evaluate car \(to the built-in primitive of the same name\), but run into)61.2 484.9 ms
(; trouble when it tries to evaluate \(a b c\).  Scheme will want to regard)61.2 474.9 ms
(; a as a function, and the values of b and c as arguments to that function.)61.2 464.9 ms
(; But we have not associated a with a function, nor any values at all with)61.2 454.9 ms
(; b or c: for us, the list \(a b c\) is just a list of symbols.  To get scheme)61.2 444.9 ms
(; to think of it in the same way, we use quote to block evaluation.  Scheme)61.2 434.9 ms
(; will regard \(quote \(a b c\)\) as the list of symbols we have in mind.  Thus)61.2 424.9 ms
(; \(car \(quote \(a b c\)\) = a, and \(cdr \(quote \(a b c\)\) = \(b c\), and so on. )61.2 414.9 ms
(; it is frequently convenient to abbreviate quote by ', the single stroke )61.2 394.9 ms
(; located under the " symbol on the keypad.  thus we will sometimes write)61.2 384.9 ms
(; \(car \(cdr '\(a b c\)\)\) instead of \(car \(cdr \(quote \(a b c\)\)\)\), etc.  )61.2 374.9 ms
(; note that quote plays well with define --)61.2 354.9 ms
0.753 0 0.753 r
(\()61.2 334.9 ms
0 0.502 0 r
(define)s
0 g
( x )s
0.753 0 0.753 r
('\()s
0 g
(a b c)s
0.753 0 0.753 r
(\)\))s
0.753 0 0 r
(; sets up x as a name to the list \(a b c\))61.2 314.9 ms
(; but observe the effect of quote on evaluation in a more familiar setting:)61.2 274.9 ms
(; if)61.2 254.9 ms
0.753 0 0.753 r
(\()61.2 234.9 ms
0 0.502 0 r
(define)s
0 g
( x )s
0 0 0.753 r
(1)s
0.753 0 0.753 r
(\))s
0.753 0 0 r
(; then)61.2 214.9 ms
0 g
(x)61.2 194.9 ms
0.753 0 0 r
(; evals to 1, while)61.2 174.9 ms
0.753 0 0.753 r
(\()61.2 154.9 ms
0 0.502 0 r
(quote)s
0 g
( x)s
0.753 0 0.753 r
(\))s
0.753 0 0 r
(; evals to the symbol x)61.2 134.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 104.9 ms
(; we move on now to develop programs using lists)61.2 84.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 64.9 ms
re sp
%%PageTrailer
%%Page: 7 7
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 7)61.2 744.9 ms
F0 sf
0.753 0 0 r
(; Consider lists of atoms)61.2 714.9 ms
(;;  lat ::= \(\) | \(cons atom lat\))61.2 684.9 ms
(; Here is a predicate of one argument, lst, which checks whether lst)61.2 644.9 ms
(; is a lat.  Note the structural similarity between this definition)61.2 634.9 ms
(; and the recipe just given.)61.2 624.9 ms
0.753 0 0.753 r
(\()61.2 594.9 ms
0 0.502 0 r
(define)s
0 g
( lat?)s
(  )61.2 584.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(lambda)s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(lst)s
0.753 0 0.753 r
(\))s
0 g
(    )61.2 574.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(cond)s
0 g
( )s
0.753 0 0.753 r
(\(\()s
0.502 0.502 0 r
(null?)s
0 g
( lst)s
0.753 0 0.753 r
(\))s
0 g
( )s
0 0 0.753 r
(#t)s
0.753 0 0.753 r
(\))s
0 g
(          )61.2 564.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(else)s
0 g
( )s
(           )61.2 554.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(and)s
0 g
(            )61.2 544.9 ms
0.753 0 0.753 r
(\()s
0 g
(atom? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(car)s
0 g
( lst)s
0.753 0 0.753 r
(\)\))s
0 g
( )s
(            )61.2 534.9 ms
0.753 0 0.753 r
(\()s
0 g
(lat? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(cdr)s
0 g
( lst)s
0.753 0 0.753 r
(\)\)\)\)\)\)\))s
0.753 0 0 r
(; \(lat? '\(bacon and eggs\)\))61.2 504.9 ms
(; \(lat? '\(bacon \(and eggs\)\)\))61.2 484.9 ms
(; an alternate design, which also corresponds \(perhaps not as closely\) to the )61.2 454.9 ms
(; definition)61.2 444.9 ms
0.753 0 0.753 r
(\()61.2 424.9 ms
0 0.502 0 r
(define)s
0 g
( alt-lat?)s
(  )61.2 414.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(lambda)s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(lst)s
0.753 0 0.753 r
(\))s
0 g
(    )61.2 404.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(cond)s
0 g
( )s
0.753 0 0.753 r
(\(\()s
0.502 0.502 0 r
(null?)s
0 g
( lst)s
0.753 0 0.753 r
(\))s
0 g
( )s
0 0 0.753 r
(#t)s
0.753 0 0.753 r
(\))s
0 g
(          )61.2 394.9 ms
0.753 0 0.753 r
(\(\()s
0 g
(atom? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(car)s
0 g
( lst)s
0.753 0 0.753 r
(\)\))s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(alt-lat? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(cdr)s
0 g
( lst)s
0.753 0 0.753 r
(\)\)\))s
0 g
(          )61.2 384.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(else)s
0 g
( )s
0 0 0.753 r
(#f)s
0.753 0 0.753 r
(\)\)\)\))s
0.753 0 0 r
(; what do you make of this?)61.2 344.9 ms
0.753 0 0.753 r
(\()61.2 324.9 ms
0 0.502 0 r
(define)s
0 g
( alt-alt-lat?)s
(  )61.2 314.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(lambda)s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(lst)s
0.753 0 0.753 r
(\))s
0 g
(    )61.2 304.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(or)s
0 g
( )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(null?)s
0 g
( lst)s
0.753 0 0.753 r
(\))s
0 g
(        )61.2 294.9 ms
0.753 0 0.753 r
(\()s
0 0.502 0 r
(and)s
0 g
( )s
0.753 0 0.753 r
(\()s
0 g
(atom? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(car)s
0 g
( lst)s
0.753 0 0.753 r
(\)\))s
0 g
(             )61.2 284.9 ms
0.753 0 0.753 r
(\()s
0 g
(alt-alt-lat? )s
0.753 0 0.753 r
(\()s
0.502 0.502 0 r
(cdr)s
0 g
( lst)s
0.753 0 0.753 r
(\)\)\)\)\)\))s
0.753 0 0 r
(; do we _ever_ actually need cond? recall our earlier discussion:  cond is a special f)61.2 264.9 ms
(orm,)61.2 254.9 ms
(; and we have seen examples where it is absolutely necessary.  Even here, the success )61.2 244.9 ms
(of )61.2 234.9 ms
(; this last definition depends on the implementation's evaluation order for or -- if o)61.2 224.9 ms
(ne)61.2 214.9 ms
(; were to modfiy the 'short-circuit' implementation of or, the function might well fai)61.2 204.9 ms
(l.)61.2 194.9 ms
(; As the logical definition of or does not depend on the evaluation order of its argum)61.2 184.9 ms
(ents,)61.2 174.9 ms
(; it is perhaps poor style \(in the sense of violating abstraction barriers\) to depend )61.2 164.9 ms
(on)61.2 154.9 ms
(; this implementation detail so heavily as in this function.)61.2 144.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 84.9 ms
(;;;)61.2 74.9 ms
(; correctness of lat?, as well as alt-lat?,  can  be established by )61.2 54.9 ms
(; induction on the length of lst.)61.2 44.9 ms
re sp
%%PageTrailer
%%Page: 8 8
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(lecture7.scm                                                                    Page 8)61.2 744.9 ms
F0 sf
0.753 0 0 r
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 714.9 ms
(;;;)61.2 704.9 ms
(; any claim of correctness requires a specification:)61.2 684.9 ms
(;   pre:  lst is a list)61.2 664.9 ms
(;)61.2 654.9 ms
(;   post: \(lat? lst\) = #t when lst is a list of atoms)61.2 644.9 ms
(;                      #f otherwise)61.2 634.9 ms
(; said another way, the post-condition for \(lat? lst\) is just 'lst is a list of atoms')61.2 614.9 ms
(; so: one shows by induction on the length of lst that lat? satisfies)61.2 594.9 ms
(; this specification: if the input parameter lst is in fact a list, then )61.2 584.9 ms
(; \(lat? lst\) returns #t iff lst is a list of atoms.  Nothing is promised)61.2 574.9 ms
(; if the input parameter is not a list. )61.2 564.9 ms
(; we sketch this argument in class, and ask you to write it up for practice)61.2 544.9 ms
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)61.2 524.9 ms
re sp
%%PageTrailer
%%Trailer
%%Pages: 8
%%EOF
